@login_required
def siso_dashboard(request):
    user = request.user

    # Ensure only SISO users can access
    if user.role != "siso" or not user.circuit:
        return redirect("homepage")

    circuit = user.circuit
    schools_in_circuit = School.objects.filter(circuit=circuit)

    # Get available academic years and terms
    filter_options = json.loads(get_available_terms(request).content)
    available_years = [year["name"] for year in filter_options.get("academic_years", [])]
    available_terms = [term["name"] for term in filter_options.get("terms", [])]

    # ✅ Ensure correct academic year and term are extracted
    academic_year = request.GET.get("academic_year", "").strip()
    term = request.GET.get("term", "").strip()

    # ✅ Ensure selected values are valid, else use defaults
    selected_year = academic_year if academic_year in available_years else filter_options.get("selected_academic_year")
    selected_term = term if term in available_terms else filter_options.get("selected_term", "Term 1")

    if not selected_year or not selected_term:
        return render(request, "dashboards/siso_dashboard.html", {
            "error": "No academic data available.",
            "academic_years": available_years,
            "terms": available_terms,
        })

    # ✅ Apply filters correctly in queries
    headteacher_results = Result.objects.filter(
        school__in=schools_in_circuit,
        academic_year=selected_year,
        term=selected_term,
        status="Submitted"
    )

    marks_qs = StudentMark.objects.filter(
        student__school__in=schools_in_circuit,
        academic_year=selected_year,
        term=selected_term,
        subject__results__status="Submitted"
    ).distinct()

    # Dashboard Stats
    total_schools = schools_in_circuit.count()
    total_teachers = sum(
        school.staff_members.filter(role__in=["teacher", "headteacher"]).count()
        for school in schools_in_circuit
    )
    total_students_assessed = marks_qs.values('student').distinct().count()
    total_circuit_average = marks_qs.aggregate(avg=Avg("mark"))["avg"] or 0

    # ✅ Ensure performance metrics apply correct filters
    best_performing_schools = list(
        marks_qs.values("student__school__name")
        .annotate(avg_mark=Avg("mark"))
        .order_by("-avg_mark")[:2]
    )
    for school in best_performing_schools:
        school["school"] = school.pop("student__school__name")
        school["average_score"] = round(school.pop("avg_mark"), 2)

    weakest_performing_schools = list(
        marks_qs.values("student__school__name")
        .annotate(avg_mark=Avg("mark"))
        .order_by("avg_mark")[:2]
    )
    for school in weakest_performing_schools:
        school["school"] = school.pop("student__school__name")
        school["average_score"] = round(school.pop("avg_mark"), 2)

    best_performing_subjects = list(
        marks_qs.values("subject__name")
        .annotate(avg_mark=Avg("mark"))
        .order_by("-avg_mark")[:3]
    )
    for subject in best_performing_subjects:
        subject["subject"] = subject.pop("subject__name")
        subject["average_score"] = round(subject.pop("avg_mark"), 2)

    weakest_performing_subjects = list(
        marks_qs.values("subject__name")
        .annotate(avg_mark=Avg("mark"))
        .order_by("avg_mark")[:3]
    )
    for subject in weakest_performing_subjects:
        subject["subject"] = subject.pop("subject__name")
        subject["average_score"] = round(subject.pop("avg_mark"), 2)

    # ✅ Performance Trends Data
    circuit_performance_trends = (
        marks_qs.values("student__school__name")
        .annotate(avg_mark=Avg("mark"))
        .order_by("student__school__name")
    )
    trend_data = [
        {"school": entry["student__school__name"], "score": round(entry["avg_mark"], 2)}
        for entry in circuit_performance_trends
    ]

    # ✅ Filtered Notifications
    notifications = (
        headteacher_results
        .values("school__name", "school__headteacher__first_name", "school__headteacher__last_name", "term", "academic_year", "class_group__name", "subject__name")
        .distinct()
        .order_by("-academic_year", "-term")[:10]
    )

    formatted_notifications = [
        f"{entry['school__headteacher__first_name']} {entry['school__headteacher__last_name']} submitted {entry['class_group__name']} {entry['subject__name']} results for {entry['school__name']} ({entry['term']} {entry['academic_year']})"
        for entry in notifications
        if entry["school__headteacher__first_name"] and entry["school__headteacher__last_name"]
    ]

    # ✅ Handle AJAX request correctly
    if request.headers.get("x-requested-with") == "XMLHttpRequest":
        return JsonResponse({
            "total_schools": total_schools,
            "total_teachers": total_teachers,
            "total_students_assessed": total_students_assessed,
            "total_circuit_average": round(total_circuit_average, 2),
            "best_performing_schools": best_performing_schools,
            "weakest_performing_schools": weakest_performing_schools,
            "best_performing_subjects": best_performing_subjects,
            "weakest_performing_subjects": weakest_performing_subjects,
            "performance_trends": trend_data,
            "notifications": formatted_notifications,
        })

    # ✅ Pass selected filters back to the template
    return render(request, "dashboards/siso_dashboard.html", {
        "academic_years": available_years,
        "terms": available_terms,
        "selected_year": selected_year,
        "selected_term": selected_term,
        "total_schools": total_schools,
        "total_teachers": total_teachers,
        "total_students_assessed": total_students_assessed,
        "total_circuit_average": round(total_circuit_average, 2),
        "best_performing_schools": best_performing_schools,
        "weakest_performing_schools": weakest_performing_schools,
        "best_performing_subjects": best_performing_subjects,
        "weakest_performing_subjects": weakest_performing_subjects,
        "performance_trends": trend_data,
        "notifications": formatted_notifications,
    })